import SpotifyWebApi = require('spotify-web-api-node');

const spotifyApi = new SpotifyWebApi({
  clientId: process.env.CLIENTID,
  clientSecret: process.env.CLIENTSECRET,
  redirectUri: 'http://localhost:3000/spotifyCallback',
});
const scopes = [
  'playlist-read-private',
  'user-library-read',
  'playlist-modify-public',
  'playlist-modify-private',
];

type popularityObj = {
  [key: string]: number;
};

const spotifyHelper = {
  combinePopularityObjs(objArray: popularityObj[]): popularityObj {
    const combinedTrack = {};
    objArray.forEach((trackObj) => {
      for (const trackId in trackObj) {
        if (combinedTrack[trackId]) {
          combinedTrack[trackId] += trackObj[trackId];
        } else {
          combinedTrack[trackId] = trackObj[trackId];
        }
      }
    });

    return combinedTrack;
  },

  getTopTracks: (trackObj: popularityObj) =>
    Object.entries(trackObj)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 100)
      .reduce((prev, [key, value]) => ({ ...prev, [key]: value }), {}),

  async createPlaylist(trackObj: popularityObj) {
    const playlistRes = await this.getSpotifyWithRetry(() =>
      spotifyApi.createPlaylist('Fuseify', {
        description: 'Generated by fuseify',
        public: true,
      })
    );
    const playlistId = playlistRes.body.id;
    const link = playlistRes.body.external_urls.spotify;
    console.log(playlistRes.body);
    await this.getSpotifyWithRetry(() => {
      spotifyApi.addTracksToPlaylist(
        playlistId,
        Object.keys(this.getTopTracks(trackObj)).map(
          (el) => `spotify:track:${el}`
        )
      );
    });
    return link;
  },

  async getSpotifyData() {
    console.time('getTracks');
    const allData = await Promise.all([
      this.getPlaylists(),
      this.getTracks(spotifyApi.getMySavedTracks),
      this.getTracks(spotifyApi.getMySavedAlbums),
    ]);
    console.timeEnd('getTracks');
    const data = this.combinePopularityObjs(allData);
    console.log(Object.keys(data).length);
    return data;
  },

  async getPlaylists() {
    const playlists = await spotifyApi.getUserPlaylists();
    const popularityArray = [];
    for (const index in playlists.body.items) {
      popularityArray.push(
        this.getTracks(
          spotifyApi.getPlaylistTracks,
          playlists.body.items[index].id
        )
      );
    }

    return this.combinePopularityObjs(await Promise.all(popularityArray));
  },

  async getSpotifyWithRetry(
    functionCall: () => Promise<any>,
    retries = 0
  ): Promise<any> {
    try {
      return await functionCall();
    } catch (err) {
      const maxRetries = 5;
      if (retries <= maxRetries) {
        if (err && err.statusCode === 429) {
          const retryAfter = (Number(err.headers['retry-after']) + 1) * 1000;
          await new Promise((r) => setTimeout(r, retryAfter));
        } else if (err && err.statusCode === 400) {
          spotifyApi.refreshAccessToken().then(
            (data) => {
              spotifyApi.setAccessToken(data.body['access_token']);
            },
            (err) => {
              console.log('Could not refresh access token', err);
            }
          );
        } else if (err && err.statusCode === 403){
          return {body: {items: []}}
        }
        return await this.getSpotifyWithRetry(functionCall, retries + 1);
      } else {
        console.log('error:');
        console.error(err);
      }
    }
  },

  async getTracks(callback: Function, args: string) {
    callback = callback.bind(spotifyApi);
    const offSetIncrement = 50;
    const trackArray = [];
    const trackPopularity: popularityObj = {};
    let firstRequst;
    console.log(callback);
    console.log(args)
    if (args) {
      firstRequst = await this.getSpotifyWithRetry(() =>
        callback(args, { limit: offSetIncrement })
      );
    } else {
      firstRequst = await this.getSpotifyWithRetry(() =>
        callback({ limit: offSetIncrement })
      );
    }

    if (!firstRequst.body || firstRequst.body.items.length === 0){
      return {}
    }
    const promiseArr = new Array(
      Math.ceil(firstRequst.body.total / offSetIncrement)
    )
      .fill(null)
      .map(async (_, i) => {
        const offset = (i + 2) * offSetIncrement;
        let tracks;
        if (args) {
          tracks = this.getSpotifyWithRetry(
            async () =>
              await callback(args, {
                offset,
                limit: offSetIncrement,
              })
          );
        } else {
          tracks = this.getSpotifyWithRetry(
            async () =>
              await callback({
                offset,
                limit: offSetIncrement,
              })
          );
        }
        return tracks;
      });
    promiseArr.push(firstRequst);
    const promisesRes = await Promise.all(promiseArr);

    promisesRes.forEach((res) => {
      if (res?.body?.items) {
        trackArray.push(
          res.body.items.map((trackObj) => {
            if (trackObj.album) {
              return trackObj.album.tracks.items.map((track) => {
                return track.id;
              });
            } else {
              return trackObj.track.id;
            }
          })
        );
      }
    });

    trackArray.flat(2).forEach((id) => {
      if (trackPopularity[id]) {
        trackPopularity[id] += 1;
      } else {
        trackPopularity[id] = 1;
      }
    });
    return trackPopularity;
  },

  getRedirectUrl: (state: string): string =>
    spotifyApi.createAuthorizeURL(scopes, state),

  async authorizeUser(code: string): Promise<void> {
    const data = await this.getSpotifyWithRetry(() =>
      spotifyApi.authorizationCodeGrant(code)
    );
    spotifyApi.setAccessToken(data.body.access_token);
    spotifyApi.setRefreshToken(data.body.refresh_token);
  },
};

export default spotifyHelper;
